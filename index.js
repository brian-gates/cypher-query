// Generated by CoffeeScript 1.6.3
(function() {
  "use strict";
  var CypherQuery, extend, isString,
    __slice = [].slice;

  isString = function(val) {
    return typeof val === 'string';
  };

  extend = function(target, source) {
    var k, v;
    for (k in source) {
      v = source[k];
      target[k] = v;
    }
    return target;
  };

  CypherQuery = (function() {
    var PARTS, compile, k, part_builder, _i, _len;

    PARTS = ['start', 'match', 'where', 'with', 'return', 'union', 'union all', 'order by', 'limit', 'skip'];

    function CypherQuery(parts) {
      var key, val;
      if (typeof this === "undefined" || this === null) {
        return new CypherQuery(parts);
      }
      if ((parts != null ? parts.params : void 0) != null) {
        this.params = parts.params;
        delete parts.params;
      } else {
        this.params = {};
      }
      this.parts = (function() {
        if (parts != null) {
          for (key in parts) {
            val = parts[key];
            if (isString(val)) {
              parts[key] = [val];
            }
          }
          return parts;
        } else {
          return {};
        }
      })();
    }

    CypherQuery.prototype.execute = function(db, cb) {
      return db.query(this.toString(), this.params, cb);
    };

    CypherQuery.prototype.toString = function() {
      return compile(this.parts);
    };

    CypherQuery.prototype.set = function(params) {
      extend(this.params, params);
      return this;
    };

    part_builder = function(key) {
      return function() {
        var params, vals, _i, _ref;
        vals = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), params = arguments[_i++];
        if (params != null) {
          if (isString(params)) {
            vals.push(params);
          } else {
            extend(this.params, params);
          }
        }
        if (this.parts[key] == null) {
          this.parts[key] = vals;
        } else {
          (_ref = this.parts[key]).push.apply(_ref, vals);
        }
        return this;
      };
    };

    for (_i = 0, _len = PARTS.length; _i < _len; _i++) {
      k = PARTS[_i];
      CypherQuery.prototype[k] = part_builder(k);
    }

    CypherQuery.prototype.index = function(index, expr, params) {
      return this.start("n=" + index + "(" + expr + ")", params);
    };

    CypherQuery.prototype.autoindex = function(expr, params) {
      return this.index('node:node_auto_index', expr, params);
    };

    CypherQuery.install = function(target) {
      if (target == null) {
        target = require('neo4j/lib/GrpahDatabase');
      }
      return target.prototype.builder = function(parts) {
        var query;
        query = new CypherQuery(parts);
        query.execute = query.execute.bind(query, this);
        return query;
      };
    };

    CypherQuery.compile = compile = function(parts) {
      var joiner, key, val;
      if (parts["return"] == null) {
        parts["return"] = ['n'];
      }
      return ((function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = PARTS.length; _j < _len1; _j++) {
          key = PARTS[_j];
          if (!((val = parts[key]) != null)) {
            continue;
          }
          joiner = key === 'where' ? ' AND ' : ', ';
          _results.push(key.toUpperCase() + ' ' + val.join(joiner));
        }
        return _results;
      })()).join("\n");
    };

    return CypherQuery;

  })();

  module.exports = CypherQuery;

}).call(this);
